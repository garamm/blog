<!DOCTYPE html><html lang="ko-KR" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="generator" content="Jekyll v4.2.0" /><meta property="og:title" content="[책/뇌를 자극하는 알고리즘] 1-1. 리스트 / 링크드 리스트" /><meta name="author" content="임가람" /><meta property="og:locale" content="ko_KR" /><meta name="description" content="링크드 리스트란? 노드(Node)를 연결해서 만드는 리스트노드: 데이터를 보관하는 필드와, 다음 노드와의 연결 고리 역할을 하는 포인터로 이루어짐 리스트의 첫 번째 노드를 헤드라 하고 마지막 노드를 테일이라고 함 데이터가 늘어날 때마다 노드를 만들어 테일에 붙임" /><meta property="og:description" content="링크드 리스트란? 노드(Node)를 연결해서 만드는 리스트노드: 데이터를 보관하는 필드와, 다음 노드와의 연결 고리 역할을 하는 포인터로 이루어짐 리스트의 첫 번째 노드를 헤드라 하고 마지막 노드를 테일이라고 함 데이터가 늘어날 때마다 노드를 만들어 테일에 붙임" /><link rel="canonical" href="/posts/linkedlist/" /><meta property="og:url" content="/posts/linkedlist/" /><meta property="og:site_name" content="Record" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2021-08-11T22:17:00+09:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="[책/뇌를 자극하는 알고리즘] 1-1. 리스트 / 링크드 리스트" /><meta name="twitter:site" content="@" /><meta name="twitter:creator" content="@임가람" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"author":{"@type":"Person","name":"임가람"},"description":"링크드 리스트란? 노드(Node)를 연결해서 만드는 리스트노드: 데이터를 보관하는 필드와, 다음 노드와의 연결 고리 역할을 하는 포인터로 이루어짐 리스트의 첫 번째 노드를 헤드라 하고 마지막 노드를 테일이라고 함 데이터가 늘어날 때마다 노드를 만들어 테일에 붙임","headline":"[책/뇌를 자극하는 알고리즘] 1-1. 리스트 / 링크드 리스트","dateModified":"2021-08-11T22:17:00+09:00","datePublished":"2021-08-11T22:17:00+09:00","url":"/posts/linkedlist/","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"/posts/linkedlist/"},"@context":"https://schema.org"}</script><title>[책/뇌를 자극하는 알고리즘] 1-1. 리스트 / 링크드 리스트 | Record</title><link rel="shortcut icon" href="/assets/img//favicon.ico"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1.1.0/dist/magnific-popup.min.css"><link rel="preload" href="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" as="script"> <script async src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/avatar.png" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Record</a></div><div class="site-subtitle font-italic"></div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/garamm" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/" aria-label="twitter" class="order-4" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['garam1362','naver.com'].join('@')" aria-label="email" class="order-5" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" class="order-6" > <i class="fas fa-rss"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Posts </a> </span> <span>[책/뇌를 자극하는 알고리즘] 1-1. 리스트 / 링크드 리스트</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>[책/뇌를 자극하는 알고리즘] 1-1. 리스트 / 링크드 리스트</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> 임가람 </span> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Wed, Aug 11, 2021, 10:17 PM" prep="on" > Aug 11 <i class="unloaded">2021-08-11T22:17:00+09:00</i> </span></div><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="2134 words">11 min</span></div></div><div class="post-content"><h2 id="링크드-리스트란">링크드 리스트란?</h2><ul><li>노드(Node)를 연결해서 만드는 리스트<br />노드: 데이터를 보관하는 필드와, 다음 노드와의 연결 고리 역할을 하는 포인터로 이루어짐<li>리스트의 첫 번째 노드를 헤드라 하고 마지막 노드를 테일이라고 함<li>데이터가 늘어날 때마다 노드를 만들어 테일에 붙임</ul><p><img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 600 150'%3E%3C/svg%3E" data-proofer-ignore data-src="/assets/img/posts/2021-08-11-linkedlist-1.png" alt="링크드 리스트 node의 구조" width="600" height="150" /></p><p><br /></p><hr /><p><br /></p><h2 id="주요-연산">주요 연산</h2><h3 id="노드-생성소멸">노드 생성/소멸</h3><p>C 언어의 세 가지 메모리 영역</p><ul><li>정적 메모리(Static Memory): 전역 번수나 정적 변수 등이 저장됨, 프로그램이 종료될 때 해제됨<li>자동 메모리(Automatic Memory): 지역 변수 저장, 스택 구조로 이루어져 있어 코드 블록이 종료될 때 해제됨<li>자유 저장소(Free Store): 프로그래머가 직접 메모리를 관리하는 영역 <br /> 자동 메모리에 노드를 생성시 함수가 종료되면 자동 메모리에서 제거되므로 자유 저장소에 노드를 생성해야 한다.<br /> 그러므로 malloc()를 사용하여 자유 저장소에 메모리를 할당한다.<br /> <br /> 노드를 소멸시키려면 자유 저장소의 free()를 사용한다.</ul><p><br /></p><h3 id="노드-추가">노드 추가</h3><p>링크드 리스트의 테일 노드 뒤에 새로운 노드를 만들어 연결한다.<br /> 자유 저장소에 노드를 생성한 다음, 새로 생선한 노드의 주소를 테일의 NextNode 포인터에 대입한다.<br /> <br /> 참고) SLL_AppendNode(Node** _Head, Node* _NewNode)의 매개 변수가 Node**인 이유</p><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="c1">// 매개 변수 Head가 Node*로 선언되었다고 가정하고 노드 생성하여 리스트에 추가</span>
<span class="n">Node</span><span class="o">*</span> <span class="n">List</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="n">Node</span><span class="o">*</span> <span class="n">NewNode</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="n">NewNode</span> <span class="o">=</span> <span class="n">SLL_CreateNode</span><span class="p">(</span><span class="mi">117</span><span class="p">);</span>
<span class="n">SLL_AppendNode</span><span class="p">(</span><span class="n">List</span><span class="p">,</span> <span class="n">NewNode</span><span class="p">);</span>
</pre></table></code></div></div><p>우선 List와 NewNode를 선언하면 자동 메모리에 두 포인터 변수가 생성되고, 이 포인터들은 아무 메모리도 가리키지 않는 상태로 초기화되어있다.</p><p><img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 600 150'%3E%3C/svg%3E" data-proofer-ignore data-src="/assets/img/posts/2021-08-11-linkedlist-2.png" alt="링크드리스트-노드추가-1" width="600" height="150" /></p><p>그 다음 SLL_CreateNode를 실행하면서 자유 저장소에 117을 가진 노드가 생성되고, NewNode가 그 주소를 가리킨다.</p><p><img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 600 150'%3E%3C/svg%3E" data-proofer-ignore data-src="/assets/img/posts/2021-08-11-linkedlist-3.png" alt="링크드리스트-노드추가-2" width="600" height="150" /></p><p>그 후 SLL_AppendNode()를 호출할 때, _Head와 _NewNode가 자동 메모리에 생성되고, List는 _Head에, NewNode는 _NewNode에 자신이 가리키고 있는 메모리의 주소를 복사한다.</p><p><img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 600 150'%3E%3C/svg%3E" data-proofer-ignore data-src="/assets/img/posts/2021-08-11-linkedlist-4.png" alt="링크드리스트-노드추가-3" width="600" height="150" /></p><p>SLL_AppendNode()는 List의 헤드가 NULL일 때, 새 노드를 헤드로 만드는데, 이 때 포인터는 메모리 주소를 담는 변수이기 때문에 SLL_AppendNode()를 호출할 때 List 포인터가 담고 있는 ‘주소 값’만 _Head에 복사되고, 정작 List 포인터 변수의 주소 자체는 전달되지 않는다.<br /> SLL_AppendNode() 호출 후에는 _Head와 _NewNode는 자동 메모리에 의해 제거되고, List는 NULL인 채로 남게된다.</p><p><img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 600 150'%3E%3C/svg%3E" data-proofer-ignore data-src="/assets/img/posts/2021-08-11-linkedlist-5.png" alt="링크드리스트-노드추가-4" width="600" height="150" /></p><p>그렇기 때문에 포인터(*)가 아닌 포인터에 대한 포인터(**)를 함수에 전달해서 포인터가 가진 값이 아닌 포인터 그 자신의 주소를 넘겨줘야 한다.<br /> **로 선언하면 Head 포인터 자신의 주소를 넘겨서 _Head 포인터는 List 포인터 변수의 주소를 가리키고, 이 주소를 이용하여 List가 NewNode의 주소(자유 저장소에 할당된 117 노드의 주소)를 가리킨다.</p><p><img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 600 150'%3E%3C/svg%3E" data-proofer-ignore data-src="/assets/img/posts/2021-08-11-linkedlist-6.png" alt="링크드리스트-노드추가-5" width="600" height="150" /></p><p><br /></p><h3 id="노드-탐색">노드 탐색</h3><p>탐색 연산은 링크드 리스트가 갖고 있는 약점 중의 하나이다.<br /> 배열은 인덱스를 이용하여 원하는 요소를 즉시 얻을 수 있지만, 링크드 리스트는 헤드부터 시작해서 다음 노드에 대한 포인터를 보며 차근차근 수를 세어야만 원하는 요소에 접근할 수 있다.</p><p><br /></p><h3 id="노드-삭제">노드 삭제</h3><p><img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 600 150'%3E%3C/svg%3E" data-proofer-ignore data-src="/assets/img/posts/2021-08-11-linkedlist-7.png" alt="링크드리스트-노드삭제" width="600" height="150" /></p><p>삭제한 노드를 쓸 곳이 없다면 삭제하는것이 좋다.</p><p><br /></p><h3 id="노드-삽입">노드 삽입</h3><p><img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 600 150'%3E%3C/svg%3E" data-proofer-ignore data-src="/assets/img/posts/2021-08-11-linkedlist-8.png" alt="링크드리스트-노드삽입" width="600" height="150" /></p><p><br /></p><hr /><p><br /></p><h2 id="링크드-리스트의-장단점">링크드 리스트의 장단점</h2><h3 id="장점">장점</h3><ul><li>새로운 노드의 추가/삽입/삭제가 배열 보다 쉽고 빠름<li>현재 노드의 다음 노드를 얻어오는 연산에 대해 비용이 발생하지 않음</ul><h3 id="단점">단점</h3><ul><li>다음 노드를 가리키려는 포인터 때문에 각 노드마다 4byte의 추가 메모리 필요<li>특정 위치에 있는 노드를 얻는데 드는 비용이 크며 속도도 느림</ul><p><br /></p><hr /><p><br /></p><h2 id="예제-코드">예제 코드</h2><p>LinkedList.h</p><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre><td class="rouge-code"><pre><span class="cp">#ifndef LINKEDLIST_H
#define LINKEDLIST_H
</span>
<span class="cp">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
</span>
<span class="k">typedef</span> <span class="kt">int</span> <span class="n">ElementType</span><span class="p">;</span>

<span class="cm">/* 노드 구조체 */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">tagNode</span> 
<span class="p">{</span>
    <span class="n">ElementType</span> <span class="n">Data</span><span class="p">;</span> <span class="cm">/* 데이터 필드 */</span>
    <span class="k">struct</span> <span class="n">tagNode</span><span class="o">*</span> <span class="n">NextNode</span><span class="p">;</span> <span class="cm">/* 다음 노드를 가리키는 포인터 */</span>
<span class="p">}</span> <span class="n">Node</span><span class="p">;</span>

<span class="cm">/* 함수 원형 선언 */</span>
<span class="n">Node</span><span class="o">*</span> <span class="nf">SLL_CreateNode</span><span class="p">(</span><span class="n">ElementType</span> <span class="n">NewData</span><span class="p">);</span>
<span class="kt">void</span>  <span class="nf">SLL_DestroyNode</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span> <span class="n">Node</span><span class="p">);</span>
<span class="kt">void</span>  <span class="nf">SLL_AppendNode</span><span class="p">(</span><span class="n">Node</span><span class="o">**</span> <span class="n">Head</span><span class="p">,</span> <span class="n">Node</span><span class="o">*</span> <span class="n">NewNode</span><span class="p">);</span>
<span class="kt">void</span>  <span class="nf">SLL_InsertAfter</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span> <span class="n">Current</span><span class="p">,</span> <span class="n">Node</span><span class="o">*</span> <span class="n">NewNode</span><span class="p">);</span>
<span class="kt">void</span>  <span class="nf">SLL_InsertNewHead</span><span class="p">(</span><span class="n">Node</span><span class="o">**</span> <span class="n">Head</span><span class="p">,</span> <span class="n">Node</span><span class="o">*</span> <span class="n">NewHead</span><span class="p">);</span>
<span class="kt">void</span>  <span class="nf">SLL_RemoveNode</span><span class="p">(</span><span class="n">Node</span><span class="o">**</span> <span class="n">Head</span><span class="p">,</span> <span class="n">Node</span><span class="o">*</span> <span class="n">Remove</span><span class="p">);</span>
<span class="n">Node</span><span class="o">*</span> <span class="nf">SLL_GetNodeAt</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span> <span class="n">Head</span><span class="p">,</span> <span class="kt">int</span> <span class="n">Location</span><span class="p">);</span>
<span class="kt">int</span>   <span class="nf">SLL_GetNodeCount</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span> <span class="n">Head</span><span class="p">);</span>

<span class="cp">#endif
</span></pre></table></code></div></div><p>LinkedList.c</p><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
</pre><td class="rouge-code"><pre><span class="cp">#include "LinkedList.h"
</span>
<span class="cm">/*  노드 생성 */</span>
<span class="n">Node</span><span class="o">*</span> <span class="nf">SLL_CreateNode</span><span class="p">(</span><span class="n">ElementType</span> <span class="n">NewData</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">Node</span><span class="o">*</span> <span class="n">NewNode</span> <span class="o">=</span> <span class="p">(</span><span class="n">Node</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">Node</span><span class="p">));</span>
    <span class="c1">// 자동 메모리에 노드를 생성시 함수가 종료되면 자동 메모리에서 제거되므로 malloc()을 사용하여 자유 저장소에 노드를 생성</span>

    <span class="n">NewNode</span><span class="o">-&gt;</span><span class="n">Data</span> <span class="o">=</span> <span class="n">NewData</span><span class="p">;</span>  <span class="cm">/*  데이터를 저장한다. */</span>
    <span class="n">NewNode</span><span class="o">-&gt;</span><span class="n">NextNode</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="cm">/*  다음 노드에 대한 포인터는 NULL로 초기화 한다. */</span>

    <span class="k">return</span> <span class="n">NewNode</span><span class="p">;</span><span class="cm">/*  노드의 주소를 반환한다. */</span>
<span class="p">}</span>

<span class="cm">/*  노드 소멸 */</span>
<span class="kt">void</span> <span class="nf">SLL_DestroyNode</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span> <span class="n">Node</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">free</span><span class="p">(</span><span class="n">Node</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*  노드 추가 */</span>
<span class="kt">void</span> <span class="nf">SLL_AppendNode</span><span class="p">(</span><span class="n">Node</span><span class="o">**</span> <span class="n">Head</span><span class="p">,</span> <span class="n">Node</span><span class="o">*</span> <span class="n">NewNode</span><span class="p">)</span>
<span class="p">{</span>
    <span class="cm">/*  헤드 노드가 NULL이라면 새로운 노드가 Head */</span>
    <span class="k">if</span> <span class="p">(</span> <span class="p">(</span><span class="o">*</span><span class="n">Head</span><span class="p">)</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="p">)</span> 
    <span class="p">{</span>        
        <span class="o">*</span><span class="n">Head</span> <span class="o">=</span> <span class="n">NewNode</span><span class="p">;</span>
    <span class="p">}</span> 
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="cm">/*  테일을 찾아 NewNode를 연결한다. */</span>
        <span class="n">Node</span><span class="o">*</span> <span class="n">Tail</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">Head</span><span class="p">);</span>
        <span class="k">while</span> <span class="p">(</span> <span class="n">Tail</span><span class="o">-&gt;</span><span class="n">NextNode</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="p">)</span>
        <span class="p">{</span>
            <span class="n">Tail</span> <span class="o">=</span> <span class="n">Tail</span><span class="o">-&gt;</span><span class="n">NextNode</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">Tail</span><span class="o">-&gt;</span><span class="n">NextNode</span> <span class="o">=</span> <span class="n">NewNode</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*  노드 삽입 */</span>
<span class="kt">void</span> <span class="nf">SLL_InsertAfter</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span> <span class="n">Current</span><span class="p">,</span> <span class="n">Node</span><span class="o">*</span> <span class="n">NewNode</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">NewNode</span><span class="o">-&gt;</span><span class="n">NextNode</span> <span class="o">=</span> <span class="n">Current</span><span class="o">-&gt;</span><span class="n">NextNode</span><span class="p">;</span>
    <span class="n">Current</span><span class="o">-&gt;</span><span class="n">NextNode</span> <span class="o">=</span> <span class="n">NewNode</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span>  <span class="nf">SLL_InsertNewHead</span><span class="p">(</span><span class="n">Node</span><span class="o">**</span> <span class="n">Head</span><span class="p">,</span> <span class="n">Node</span><span class="o">*</span> <span class="n">NewHead</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">Head</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="p">(</span><span class="o">*</span><span class="n">Head</span><span class="p">)</span> <span class="o">=</span> <span class="n">NewHead</span><span class="p">;</span>    
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="n">NewHead</span><span class="o">-&gt;</span><span class="n">NextNode</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">Head</span><span class="p">);</span>
        <span class="p">(</span><span class="o">*</span><span class="n">Head</span><span class="p">)</span> <span class="o">=</span> <span class="n">NewHead</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*  노드 제거 */</span>
<span class="kt">void</span> <span class="nf">SLL_RemoveNode</span><span class="p">(</span><span class="n">Node</span><span class="o">**</span> <span class="n">Head</span><span class="p">,</span> <span class="n">Node</span><span class="o">*</span> <span class="n">Remove</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span> <span class="o">*</span><span class="n">Head</span> <span class="o">==</span> <span class="n">Remove</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="o">*</span><span class="n">Head</span> <span class="o">=</span> <span class="n">Remove</span><span class="o">-&gt;</span><span class="n">NextNode</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="n">Node</span><span class="o">*</span> <span class="n">Current</span> <span class="o">=</span> <span class="o">*</span><span class="n">Head</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span> <span class="n">Current</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">Current</span><span class="o">-&gt;</span><span class="n">NextNode</span> <span class="o">!=</span> <span class="n">Remove</span> <span class="p">)</span>
        <span class="p">{</span>
            <span class="n">Current</span> <span class="o">=</span> <span class="n">Current</span><span class="o">-&gt;</span><span class="n">NextNode</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="p">(</span> <span class="n">Current</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="p">)</span>
            <span class="n">Current</span><span class="o">-&gt;</span><span class="n">NextNode</span> <span class="o">=</span> <span class="n">Remove</span><span class="o">-&gt;</span><span class="n">NextNode</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*  노드 탐색 */</span>
<span class="n">Node</span><span class="o">*</span> <span class="nf">SLL_GetNodeAt</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span> <span class="n">Head</span><span class="p">,</span> <span class="kt">int</span> <span class="n">Location</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">Node</span><span class="o">*</span> <span class="n">Current</span> <span class="o">=</span> <span class="n">Head</span><span class="p">;</span>

    <span class="k">while</span> <span class="p">(</span> <span class="n">Current</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">--</span><span class="n">Location</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">Current</span> <span class="o">=</span> <span class="n">Current</span><span class="o">-&gt;</span><span class="n">NextNode</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">Current</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*  노드 수 세기 */</span>
<span class="kt">int</span> <span class="nf">SLL_GetNodeCount</span><span class="p">(</span><span class="n">Node</span><span class="o">*</span> <span class="n">Head</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span>   <span class="n">Count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">Node</span><span class="o">*</span> <span class="n">Current</span> <span class="o">=</span> <span class="n">Head</span><span class="p">;</span>

    <span class="k">while</span> <span class="p">(</span> <span class="n">Current</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="n">Current</span> <span class="o">=</span> <span class="n">Current</span><span class="o">-&gt;</span><span class="n">NextNode</span><span class="p">;</span>
        <span class="n">Count</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">Count</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>Test_LinkedList.c</p><div class="language-c highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
</pre><td class="rouge-code"><pre><span class="cp">#include "LinkedList.h"
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span> <span class="kt">void</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span>   <span class="n">i</span>       <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span>   <span class="n">Count</span>   <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">Node</span><span class="o">*</span> <span class="n">List</span>    <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">Node</span><span class="o">*</span> <span class="n">Current</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">Node</span><span class="o">*</span> <span class="n">NewNode</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

    <span class="cm">/*  노드 5개 추가 */</span>
    <span class="k">for</span> <span class="p">(</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">5</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="n">NewNode</span> <span class="o">=</span> <span class="n">SLL_CreateNode</span><span class="p">(</span><span class="n">i</span><span class="p">);</span> <span class="cm">/* 자유 저장소에 노드 생성 */</span>
        <span class="n">SLL_AppendNode</span><span class="p">(</span><span class="o">&amp;</span><span class="n">List</span><span class="p">,</span> <span class="n">NewNode</span><span class="p">);</span> <span class="cm">/* 생성한 노드를 List에 추가 */</span>
    <span class="p">}</span>

    <span class="n">NewNode</span> <span class="o">=</span> <span class="n">SLL_CreateNode</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
    <span class="n">SLL_InsertNewHead</span><span class="p">(</span><span class="o">&amp;</span><span class="n">List</span><span class="p">,</span> <span class="n">NewNode</span><span class="p">);</span>

    <span class="n">NewNode</span> <span class="o">=</span> <span class="n">SLL_CreateNode</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">);</span>
    <span class="n">SLL_InsertNewHead</span><span class="p">(</span><span class="o">&amp;</span><span class="n">List</span><span class="p">,</span> <span class="n">NewNode</span><span class="p">);</span>

    <span class="cm">/*  리스트 출력 */</span>
    <span class="n">Count</span> <span class="o">=</span> <span class="n">SLL_GetNodeCount</span><span class="p">(</span><span class="n">List</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">Count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="n">Current</span> <span class="o">=</span> <span class="n">SLL_GetNodeAt</span><span class="p">(</span><span class="n">List</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"List[%d] : %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">Current</span><span class="o">-&gt;</span><span class="n">Data</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="cm">/*  리스트의 세번째 노드 뒤에 새 노드 삽입 */</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">Inserting 3000 After [2]...</span><span class="se">\n\n</span><span class="s">"</span><span class="p">);</span>

    <span class="n">Current</span> <span class="o">=</span> <span class="n">SLL_GetNodeAt</span><span class="p">(</span><span class="n">List</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
    <span class="n">NewNode</span>  <span class="o">=</span> <span class="n">SLL_CreateNode</span><span class="p">(</span><span class="mi">3000</span><span class="p">);</span>

    <span class="n">SLL_InsertAfter</span><span class="p">(</span><span class="n">Current</span><span class="p">,</span> <span class="n">NewNode</span><span class="p">);</span>

    <span class="cm">/*  리스트 출력 */</span>
    <span class="n">Count</span> <span class="o">=</span> <span class="n">SLL_GetNodeCount</span><span class="p">(</span><span class="n">List</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">Count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="n">Current</span> <span class="o">=</span> <span class="n">SLL_GetNodeAt</span><span class="p">(</span><span class="n">List</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"List[%d] : %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">Current</span><span class="o">-&gt;</span><span class="n">Data</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="cm">/*  모든 노드를 메모리에서 제거     */</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">Destroying List...</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>

    <span class="k">for</span> <span class="p">(</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">Count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="n">Current</span> <span class="o">=</span> <span class="n">SLL_GetNodeAt</span><span class="p">(</span><span class="n">List</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

        <span class="k">if</span> <span class="p">(</span> <span class="n">Current</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="p">)</span> 
        <span class="p">{</span>
            <span class="n">SLL_RemoveNode</span><span class="p">(</span><span class="o">&amp;</span><span class="n">List</span><span class="p">,</span> <span class="n">Current</span><span class="p">);</span> <span class="cm">/* 리스트에서 선택된 노드 제거 */</span>
            <span class="n">SLL_DestroyNode</span><span class="p">(</span><span class="n">Current</span><span class="p">);</span> <span class="cm">/* 제거된 노드를 메모리에서 완전히 소멸 */</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>실행 결과</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre><td class="rouge-code"><pre>List[0] : -2
List[1] : -1
List[2] : 0
List[3] : 1
List[4] : 2
List[5] : 3
List[6] : 4


Inserting 3000 After [2]...

List[0] : -2
List[1] : -1
List[2] : 0
List[3] : 3000
List[4] : 1
List[5] : 2
List[6] : 3
List[7] : 4
</pre></table></code></div></div><p><br /></p><p># 참고<br /> <a href="https://www.hanbit.co.kr/media/books/book_view.html?p_code=B3450156021" target="_blank">박상현 / 뇌를 자극하는 알고리즘</a><br /></p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/%EC%B1%85/'>책</a>, <a href='/categories/%EB%87%8C%EB%A5%BC-%EC%9E%90%EA%B7%B9%ED%95%98%EB%8A%94-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/'>뇌를 자극하는 알고리즘</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/%EB%87%8C%EB%A5%BC-%EC%9E%90%EA%B7%B9%ED%95%98%EB%8A%94-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/" class="post-tag no-text-decoration" >뇌를 자극하는 알고리즘</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=[책/뇌를 자극하는 알고리즘] 1-1. 리스트 / 링크드 리스트 - Record&url=/posts/linkedlist/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=[책/뇌를 자극하는 알고리즘] 1-1. 리스트 / 링크드 리스트 - Record&u=/posts/linkedlist/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=[책/뇌를 자극하는 알고리즘] 1-1. 리스트 / 링크드 리스트 - Record&url=/posts/linkedlist/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/go-start/">[Go] 시작하기</a><li><a href="/posts/python3-functions/">[Python 3] 내장 함수, 표준 라이브러리 정리</a><li><a href="/posts/go-mysql/">[Go] MySQL 사용하기</a><li><a href="/posts/go-socket/">[Go] 소켓 통신</a><li><a href="/posts/go-hangul-2byte/">[Go] Go에서 한글 2Byte로 계산하기</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/%EB%87%8C%EB%A5%BC-%EC%9E%90%EA%B7%B9%ED%95%98%EB%8A%94-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/">뇌를 자극하는 알고리즘</a> <a class="post-tag" href="/tags/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/">프로그래머스</a> <a class="post-tag" href="/tags/%EC%A0%95%EB%A0%AC/">정렬</a> <a class="post-tag" href="/tags/clean-code/">Clean Code</a> <a class="post-tag" href="/tags/%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0/">시작하기</a> <a class="post-tag" href="/tags/encoding/">encoding</a> <a class="post-tag" href="/tags/mysql%EC%97%B0%EB%8F%99/">MySQL연동</a> <a class="post-tag" href="/tags/%EB%82%B4%EC%9E%A5%ED%95%A8%EC%88%98/">내장함수</a> <a class="post-tag" href="/tags/%EC%86%8C%EC%BC%93%ED%86%B5%EC%8B%A0/">소켓통신</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/doubly-linkedlist/"><div class="card-body"> <span class="timeago small" > Aug 12 <i class="unloaded">2021-08-12T23:41:00+09:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>[책/뇌를 자극하는 알고리즘] 1-2. 리스트 / 더블 링크드 리스트</h3><div class="text-muted small"><p> 더블 링크드 리스트란? 링크드 리스트의 탐색 기능을 개선한 자료구조 양방향으로 탐색 가능 링크드 리스트의 노드는 다음 노드를 가리키는 포인터만 가지고 있었는데, 더블 링크드 리스트의 노드는 이전 노드를 가리키는 포인터도 갖고 있음 주요 연산 노드 생성/소멸 링크드 리스트에서 이전 노드인 PrevNode에 NULL을 대입하여...</p></div></div></a></div><div class="card"> <a href="/posts/circular-doubly-linkedlist/"><div class="card-body"> <span class="timeago small" > Aug 13 <i class="unloaded">2021-08-13T22:24:00+09:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>[책/뇌를 자극하는 알고리즘] 1-3. 리스트 / 환형 링크드 리스트</h3><div class="text-muted small"><p> 환형 링크드 리스트란? 헤드가 테일과 연결된 형태의 링크드 리스트 주요 연산 테일은 헤드의 ‘앞 노드’이다. 헤드는 테일의 ‘뒷 노드’이다. 노드 추가 리스트가 비어있다면 새로운 노드는 헤드가 되고, 헤드의 앞 노드는 헤드 자신이 된다. 리스트가 비어있지 않은 경우엔 테일과 헤드 사이에 새 노드를 삽입한다. ...</p></div></div></a></div><div class="card"> <a href="/posts/stack-array/"><div class="card-body"> <span class="timeago small" > Aug 13 <i class="unloaded">2021-08-13T23:07:00+09:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>[책/뇌를 자극하는 알고리즘] 2-1. 스택 / 배열로 구현하기</h3><div class="text-muted small"><p> 중위 표기법과 후위 표기법 중위 표기법: 연산자를 피연산자 가운데에 위치시키는 것, 우리가 일반적으로 사용하는 표기법ex. 1 + 3 후위 표기법: 연산자를 피연산자 뒤에 위치시키는 것ex. 1 3 + 폴리쉬 표기법(전위 표기법): 연산자를 피연산자 앞에 위치시키는 것+ 1 3 후위 표기식을 계산하는 알고리즘 규칙 왼쪽부터 요소를...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/cleancode-2/" class="btn btn-outline-primary" prompt="Older"><p>[책/Clean Code] 2. 의미 있는 이름</p></a> <a href="/posts/doubly-linkedlist/" class="btn btn-outline-primary" prompt="Newer"><p>[책/뇌를 자극하는 알고리즘] 1-2. 리스트 / 더블 링크드 리스트</p></a></div><div id="disqus" class="pt-2 pb-2"><p class="text-center text-muted small pb-5"> Comments powered by <a href="https://disqus.com/">Disqus</a>.</p></div><script src="/assets/js/lib/jquery.disqusloader.min.js"></script> <script> const options = { scriptUrl: '//garamm.disqus.com/embed.js', disqusConfig: function() { this.page.title = '[책/뇌를 자극하는 알고리즘] 1-1. 리스트 / 링크드 리스트'; this.page.url = '/posts/linkedlist/'; this.page.identifier = '/posts/linkedlist/'; } }; $.disqusLoader('#disqus', options); </script></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2021 <a href="">가람</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/%EB%87%8C%EB%A5%BC-%EC%9E%90%EA%B7%B9%ED%95%98%EB%8A%94-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/">뇌를 자극하는 알고리즘</a> <a class="post-tag" href="/tags/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/">프로그래머스</a> <a class="post-tag" href="/tags/%EC%A0%95%EB%A0%AC/">정렬</a> <a class="post-tag" href="/tags/clean-code/">Clean Code</a> <a class="post-tag" href="/tags/%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0/">시작하기</a> <a class="post-tag" href="/tags/encoding/">encoding</a> <a class="post-tag" href="/tags/mysql%EC%97%B0%EB%8F%99/">MySQL연동</a> <a class="post-tag" href="/tags/%EB%82%B4%EC%9E%A5%ED%95%A8%EC%88%98/">내장함수</a> <a class="post-tag" href="/tags/%EC%86%8C%EC%BC%93%ED%86%B5%EC%8B%A0/">소켓통신</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script async src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id="></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', ''); }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/lozad/dist/lozad.min.js,npm/magnific-popup@1/dist/jquery.magnific-popup.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script>
